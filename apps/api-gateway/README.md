# API Gateway

The API Gateway exposes the platform's domain capabilities via GraphQL and REST interfaces. It will aggregate requests across services, enforce authentication/authorization policies, and manage protocol translation for realtime transports.

Key responsibilities:
- Provide a unified schema for studio clients and third-party integrations.
- Coordinate realtime collaboration sessions via WebSocket or WebRTC signaling.
- Act as the entry point for AI-assisted operations and job orchestration APIs.
- Apply rate limiting, logging, and tracing to surface operational insights.

## Available endpoints

The lightweight development gateway currently exposes a REST surface that the Studio client consumes while we build out the
real microservices:

- `GET /health` &mdash; liveness probe used by local automation scripts.
- `GET /sessions` &mdash; returns a list of active collaboration sessions and their current pose counts.
- `POST /sessions` &mdash; seeds a new session for a set of participants.
- `GET /sessions/:id` &mdash; fetches a session with its most recent 50 poses.
- `POST /sessions/:id/poses` &mdash; appends a pose snapshot generated by the worker or imported from DCC tools.
- `POST /poses` &mdash; requests an AI-generated pose and optionally persists it back to a session.

The GraphQL schema mirrors the session life-cycle with `activeSessions`, `session(id)`, and mutations for `createSession`,
`recordPose`, and `suggestPose` when the Studio wants to operate over a single transport.

## Session persistence

For repeatable demos the gateway persists collaboration sessions to JSON. Configure the storage location with the
`SESSION_STORE_PATH` environment variable (defaults to `data/sessions.json`). When running via the root `npm run dev` command the
path is set to `data/dev-sessions.json` automatically so each developer receives an isolated history.
